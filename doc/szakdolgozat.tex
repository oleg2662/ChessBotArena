% =============================================================================================================
% === PREAMBLE ================================================================================================
% =============================================================================================================

\documentclass[twoside, a4paper, 12pt]{article}
\usepackage{arabtex}
\usepackage{utf8}
\usepackage[utf8]{inputenc}
\usepackage{arabtex}
\usepackage[magyar]{babel}
\usepackage{bookman}
\usepackage{thesis-style}
\usepackage{graphicx,wrapfig}
\usepackage{cite}
\usepackage{url}
\usepackage{hyperref}
\usepackage{amssymb,amsmath}
\usepackage{lipsum}% just to generate text for the example
\usepackage{indentfirst}
\usepackage{subcaption}
\usepackage{mwe}

\newtheorem{definition}{Definíció}

\renewcommand{\listoffigures}{\begingroup
\tocsection
\tocfile{\listfigurename}{lof}
\endgroup}

\renewcommand{\listoftables}{\begingroup
\tocsection
\tocfile{\listtablename}{lot}
\endgroup}


% --- Code listing def -------------------------------------------------------------------

\usepackage{color}
\usepackage{listings}

\definecolor{red}{rgb}{0.6,0,0} % for strings
\definecolor{blue}{rgb}{0,0,0.6}
\definecolor{green}{rgb}{0,0.8,0}
\definecolor{cyan}{rgb}{0.0,0.6,0.6}

\lstloadlanguages{[Sharp]C}

\lstset{
	language={[Sharp]C},
	basicstyle=\color{black}\ttfamily\scriptsize, 
	tabsize=2, 
	extendedchars=true, 
	breaklines=true, 
	stringstyle=\color{blue}\ttfamily\scriptsize, 
	showspaces=false, 
	showtabs=false, 
	xleftmargin=5pt,
	framexleftmargin=5pt,
	framexrightmargin=2pt,
	framexbottommargin=2pt,
	commentstyle=\color{green}\ttfamily\scriptsize,
	showstringspaces=false, 
	keywordstyle=\color{cyan}\ttfamily\scriptsize,
	morekeywords={ abstract, event, new, struct, as, explicit, null, switch, base, extern, object, this, bool, false, operator, throw, break, finally, out, true, byte, fixed, override, try, case, float, params, typeof, catch, for, private, uint, char, foreach, protected, ulong, checked, goto, public, unchecked, class, if, readonly, unsafe, const, implicit, ref, ushort, continue, in, return, using, decimal, int, sbyte, virtual, default, interface, sealed, volatile, delegate, internal, short, void, do, is, sizeof, while, double, lock, stackalloc, else, long, static, enum, namespace, string },
	sensitive=true,
	morecomment=[l]{//},
	morecomment=[s]{/*}{*/},
	morestring=[b]"
}

%\usepackage{caption}
%\DeclareCaptionFont{white}{\color{white}}
%\DeclareCaptionFormat{listing}{\colorbox{blue}{\parbox{\textwidth}{\hspace{15pt}#1#2#3}}} %changed \colorbox{8} to \colorbox{blue} cause 8 is not a color!
%\captionsetup[lstlisting]{format=listing,labelfont=white,textfont=white, singlelinecheck=false, margin=0pt, font={bf,footnotesize}}

\renewcommand{\lstlistingname}{Kódrészlet}% 
\renewcommand{\lstlistlistingname}{Kódrészletek listája}

% --- Code listing def (END) --------------------------------------------------------------

\input{meta/metadata}
\lstdefinestyle{sharpc}{language=[Sharp]C, frame=lr, rulecolor=\color{blue!80!black}}
\title{\THESISTITLE}
\author{\THESISAUTHOR}
\date{\THESISDEFENCEYEAR}

\begin{document}
\pagestyle{empty}

\include{meta/coverpage}
\cleardoublepage

%place of the thesis subject registration form
\null
\vspace*{\fill}
\begin{figure}[htbp]
	\centering
	\includegraphics[width=1.0\textwidth]{img/bots_chess.png}
	\caption{Robotok sakkoznak a Futurama \copyright című sorozat egyik epizódjában.}
	\label{fig:bots_chess}
\end{figure}
\vspace*{\fill}
\null
\cleardoublepage

% table of contents
\tableofcontents
\cleardoublepage


\pagestyle{plain}
\setcounter{page}{1}











































% ============================================================================================================
% === ÖSSZEFOGLALÁS ==========================================================================================
% ============================================================================================================
\newpage
\part{Bevezető}
\section{A dolgozatról}
\subsection{A dolgozat célja}
A dolgozat célja a mesterséges intelligencia kurzuson bemutatott \textbf{„kétszemélyes, teljes információjú, diszkrét, véges és determinisztikus, zéró-összegű, játékok”} algoritmusainak bemutatása a gyakorlatban, illetve az érdeklődőbb hallgatók bevonása egy olyan játékba, melyen keresztül elmélyíthetik tudásukat ezen algoritmusokból.

E célból a (normál) sakkot vesszük alapul, mely elég bonyolult ahhoz, hogy látványos eredményeket láthassunk, a legtöbben ismerik a szabályait, illetve egy klasszikus példája a fent nevezett játékok halmazának.

A dolgozat "mellékterméke" egy olyan \textit{API interface}, melyhez kapcsolódva nem csak mesterséges intelligenciát megvalósító programok, hanem "sima", emberi játékosok által is használható kliens is írható, így a téma iránt nem érdeklődők is kipróbálhatják magukat például egy mobilalkalmazás vagy egy asztali Windows / Linux alapú kliens megírásában, illetve tapasztalatra tehetnek szert az elosztott rendszerek működésében és az aszinkron programozás felettéb érdekes és néha nagy fejfájást okozó működésében is.

\subsection{A dolgozat felépítése}
A dolgozat három fő részből áll: jelen bevezető, a fejlesztői és a felhasználói dokumentáció.
A fejlesztői dokumentáció négy fő részre tagozódik: \textbf{"elemzés"}, \textbf{"tervezés"}, \textbf{"megvalósítás"} és \textbf{"tesztelés"} - míg a felhasználói dokumentáció a programcsomag alkalmazásai mentén van szétvágva, és mindegyiknél szót ejt a \textbf{telepítésről}, \textbf{használatról} illetve a \textbf{karbantartásról}.
A dolgozat végén kiegészítésként a függelék tartalmaz néhány a megértést segítő információt a dolgozattal kapcsolatban, illetve néhány érdekességet, tapasztalatokat.











































% ============================================================================================================
% === FEJLESZTŐI DOKUMENTÁCIÓ ================================================================================
% ============================================================================================================
\newpage
\part{Fejlesztői Dokumentáció}
\section{Elemzés}

Az architektúra alapja egy sima szerver-kliens kapcsolat: (\ref{fig:highLevelArchitecture} ábra.)

\begin{figure}[htbp]
	\centering
	\includegraphics[width=1.0\textwidth]{img/highLevelArchitecture.png}
	\caption{Magas-szintű architektúra}
	\label{fig:highLevelArchitecture}
\end{figure}

A játék jellegéből adódóan nem kell valósidejűnek lenni, a levelezési-sakk logikáját követjük: a szerver egy \textbf{RESTful} szolgáltatást nyújthat a kliensek felé. Ez azt jelenti, hogy a szerver nem tárol információt a klienssel fennálló kapcsolatról, a kliens elegendő információt kell hogy küldjön a szervernek ahhoz, hogy az válaszolni tudjon. A kliens lekérdezi, hogy milyen partijai vannak, és ha van olyan, amelyre tud (és akar) válaszolni, akkor válaszol.

A klienseket ketté lehet bontani az alapján, hogy ki hozza a döntéseket. Ezek szerint lesz az "emberi" kliens, ahol emberi játékosok tudnak játszani, illetve lesznek a "bot" kliensek, melyek minimális vagy semmilyen emberi beavatkozással tudnak válaszolni a bejövő kérésekre.

Továbbá mivel az is a dolgozat célja, hogy megkönnyítse a jövőbeli bot- vagy kliensfejlesztők munkáját és ne kelljen a sakk szabályaival, reprezentációjával foglalkozniuk, ezért kellenek ezek, mint könyvtárak: külön egy általános algoritmus- és külön egy reprezentáció-könyvtár.

Így körülbelül össze is állt a kép, a programcsomag a következő részekből fog állni:

\begin{itemize}
	
	\item \textbf{Játék-reprezentáció} (könyvtár)
	\begin{itemize}
		\item Definiálja a reprezentációhoz szükséges interface-eket.
		\item Implementálja a sakk reprezentációját és mechanikáját.
		\item Könnyen használható és kiterjeszthető más alkalmazásokban.
	\end{itemize}

	\item \textbf{Algoritmusok} (könyvtár)
	\begin{itemize}
		\item Definiál egy interface-t
		\item Tartalmazza néhány algoritmus általános implementációját:
		\begin{itemize}
			\item Minimax, átlagoló minimax
			\item Alfa-béta
			\item Egyéb egyszerűbb példák (random, mohó)
		\end{itemize}
		\item Könnyen használható és kiterjeszthető más alkalmazásokban.
	\end{itemize}

	\item \textbf{Infrastruktúra}
	\begin{itemize}
		\item \textbf{Szerver}
		\begin{itemize}
			\item Felhasználó regisztrációja / hitelesítése / nyomonkövetése.
			\item Ellenőrzi a kliensektől jövő lépések érvényességét.
			\item Közvetíti a kliensek felé a partik alakulását.
		\end{itemize}
	
		\item \textbf{Kliens (humán vagy MI kliens)}
		\begin{itemize}
			\item Felhasználó beléptetése, nyomonkövetése.
			\item Közvetíti a felhasználó felé a partik alakulását.
			\item A játékos döntéseit közvetíti a szerver felé.
			\item Példakliensek implementálása:
			\begin{itemize}
				\item Android alkalmazás emberi játékosoknak.
				\item MI bot alkalmazás / alkalmazások melyek különböző algoritmusokat használnak.
			\end{itemize}
		\end{itemize}
	\end{itemize}
\end{itemize}

\newpage
\subsection{Játék-reprezentáció}
A bevezetőben láthattuk, hogy a következő lehetséges lépések megállapításához nem elég a "táblát látni", kell hozzá még néhány többletinformáció. Ilyen például a már említett bábuk cimkézése illetve ezt helyettesítve (vagy ezzel együtt alkalmazva) a játszma addigi lépéseinek nyilvántartása.

A triviális lépésektől eltekintve problémába merülhet fel, ha például a sáncolást vesszük szemügyre: ahhoz, hogy sáncolhassunk, a benne résztvevő bábuknak nem elég a helyükön lenni, de az is elvárás tőlük, hogy nem is mozoghattak előtte. Azaz például a király vagy a bástya habár (miután elmozdult) visszaléphet az eredeti helyére, ám ekkor már nem lehetséges a sáncolás. Másik ilyen példa a kevésbé ismert "\textit{en passant}" ütés. Ez akkor következik be, amikor az ellenfél az egyik gyalogjával kettőt lép előre pont a mi gyalogunk mellé. Ebben az esetben a következő (és csakis a következő) körben leüthető úgy, mintha nem kettőt, csak egyet lépett volna eredetileg előre. Viszont fontos, hogy ha nem ütjük le, akkor a következő körben ezt már nem tehetjük meg. Ezekben az esetekben adódik az ötlet: rakjunk jelzéseket a bábukra: jelezzük, ha már elmozdultak az eredeti helyükhöz képest vagy például a gyalogot megjelölhetjük, hogy "en passant" üthető. (Ez utóbbi jelzőt viszont a következő körben le is kell venni róla.)

Másik érdekes (és versenyeken alkalmazott) szabály az, hogy ha többször fordul elő ugyanaz az állapot, akkor a játékosok felajánlhatnak döntetlent a másiknak. Ehhez viszont ismerni kell az előző lépéseket, a táblára "simán csak ránézve" ezt a szabályt nem lehet alkalmazni.

Ezekből a példákból látszik, hogy nem elég a tábla aktuális állapotának ismerete, ahhoz kell még extra információ is például a bábukról (elmozdult? en passant üthető?) ami mondjuk egy a bábukra tett jelöléssel megoldható lenne, viszont a legutóbb emlegetett problémára nem megoldás: ahhoz kell az előző lépések listája is.

Megjegyzés: \textit{Ennek egyébként egy érdekes hatása lesz majd az alkalmazott reprezentációra: ha a lehetséges lépések kiszámításához elég lenne "ránézni" a táblára, akkor a játékot reprezentáló gráfunk nem lenne fa, hiszen egy bizonyos állapotba több úton is eljuthatunk. Ha azonban belevesszük egy játékállás reprezentációjához a parti addigi történelmét is, akkor az állások egyediek lesznek és a gráfunk fa-szerű lesz.}


\subsection{Algoritmusok}
\subsubsection{A probléma komplexitása}
A sakk reprezentációja tehát már látható. Fogalmazzuk meg a problémát: szeretnénk egy olyan programot, amely legyőzi a másik játékost (vagy legalábbis nem veszít), ami ekvivalens azzal, hogy minden egyes lépésnél a legoptimálisabb lépést választja.

Tekintsük egy sakkjátszmát: egy átlagos meccs 35-40 fordulós~\cite{averageLengthOfChessGame}\cite{averageLengthOfChessGame2}\cite{chessStatistics}, az átlagos lehetséges lépések száma egy adott állapotból 20\cite{shannonnumber}. Shannon adott egy alsó-korlátot a lehetséges játékok számára, amely $10^{120}$. \footnote{Összehasonlításképp: a világegyetemben levő atomok számát $10^{80}$ darabra teszik, a világegyetem pedig körülbelül $4.32 \times 10^{17}$ másodperce keletkezett, ami kevesebb, mint $10^{18}$-on, ami még így is sok nagyságrenddel kevesebb, mint a lehetséges játékok száma.} Ebből látható, hogy \textit{brute-force} technikával, a jelenlegi technikai háttérrel nem érdemes hozzákezdeni.

Látható, hogy a probléma elég bonyolult és ezért egzakt megoldása nem létezik egyelőre, csak közelíteni tudjuk. A továbbiakban az algoritmus általánosan fogalmazzuk meg és formalizáljuk, de a sakkon keresztüli példákon mutatjuk be.

\subsubsection{Egy általános táblás játékmenet}
Egy játékot meghatározza a \textbf{kezdőállapota} és az állapotok közötti lehetséges \textbf{állapotátmenetek}. Egy állapot akkor érvényes, ha a kezdőállapotból bármilyen úton eljuthatunk a megadott állapotba. Ezután már adódik az ötlet: egy játékmenetet reprezentálhatunk egy \textbf{\textit{cimkézett}, irányított gráffal}, ahol a csomópontok a lehetséges állapotok, az élek pedig az átmenetek.

\subsubsection{A probléma, mint útkeresési algoritmus}
Láthatjuk, hogy így egy játékmenet egy irányított gráf bejárása lesz. A probléma pedig amit az algoritmussal meg szeretnénk oldani (vagy közelíteni) pedig az, hogy találjunk egy olyan útvonalat ebben a gráfban, amelyben az ellenfél nyereségét minimalizáljuk amellett, hogy feltételezzük: az ellenfél mindig a számára legoptimálisabb lépést fogja választani.

A sakk nem más, mint egy körökre osztott két személyes táblás játék és a fenti analógia alkalmazható rá: Kezdetben van egy kezdőállapot. (Felállított bábúk a táblán, világos játékos kijelölve mint kezdőjátékos). Ezek után az állapotátmeneti függvény határozza meg a lehetséges lépések halmazát, amelyből egy irányt kiválasztva és követve egy új állapotba kerülünk, és így tovább. Ez lesz a játék \textbf{játékgráfja}.

Erről a gráfról semmi érdemlegeset nem állíthatunk, nem speciális, hiszen előfordulhat, hogy más utakon is eljuthatunk ugyanazon csúcsba, tehát nagy valószínűség szerint nem fa. Ezt a problémát megszüntethetjük többféle módon, például: 

\begin{itemize}
	\item \textbf{Csomópont duplázással} \\
	Ilyenkor az történik, hogy ha egy állapotba több úton is eljuthatunk, akkor ezeket a csúcsokat többszörözzük. \\
	(Lásd.: \ref{fig:game-graph-transformation} ábra.)
	
	\item \textbf{Ügyes reprezentációval} \\
	Ilyenkor azt tesszük, hogy elgondolkodunk: attól, hogy ugyanabba a csomópontba jutunk több úton, az nem jelenti-e esetleg azt, hogy a más úton elért csúcs már inkább egy másik csúcs. Sakkos példánál maradva: ezt úgy érhetjük el, hogy egy állapot reprezentációjába bevesszük az odavezető utakat. Például előállhat egy hasonló állapot, ha mi is és az ellenfél is előrelép majd vissza ugyanazzal a bábuval.
\end{itemize}

\begin{figure}[htbp]
	\centering
	\includegraphics[width=1.0\textwidth]{img/game-graph-transformation.png}
	\caption{Általános irányított gráfból irányított fa konstruálása}
	\label{fig:game-graph-transformation}
\end{figure}

\subsubsection{Nem is kell feltétlenül fa}
Tegyük fel, hogy van egy algoritmusunk, amely kiszámítja a saját és az ellenfél legmegfelelőbb lépéseit a játék végéig. Így megkapjuk az utat ami a mi győzelmünkhöz vagyis legalább az éppen legjobb elérhető eredményhez vezet. Ez nem feltétlen célravezető, hiszen mi történik akkor, ha az ellenfél végül nem azt a lépést lépi valamilyen okból? (Lehet, hogy az ő algoritmusa jobb vagy rosszabb, mint a mienk. Lehet, hogy más kiértékelőfüggvényt használ, stb.) Ekkor azt látjuk, hogy a sok munka, amellyel felépítettük az utat, kárba vész. Ezért nem érdemes az egész utat felépíteni, elég csak annyit elvárni tőle, hogy adjon egy javaslatot a következő lépésre. Természetesen a "hogyan" kérdésre a válasz lehet elég bonyolult is (minimax-, alfa-béta-, genetikus- és tanuló-algoritmusok trükkös heurisztikákkal), de a vége ugyanaz: egy lehetőleg legoptimálisabb lépés kiszámítása. Mivel nem fogjuk bejárni az egész fát csak egy adott mélységig, ezért a lépések száma véges lesz, így már nem probléma ha a gráf nem fa (azaz van benne kör), így a probléma nem is biztos, hogy létezik.

\subsection{Infrastruktúra}
A bevezetőben már volt róla szó: mivel kérés-válasz párokra épül maga az eredeti játék is, ezért egy RESTful szolgáltatás építése tünik a legmegfelelőbbnek amely JSON-ban kommunikál. Ez azért is lesz jó, mivel így bármilyen platformon viszonylag könnyű lesz hozzá klienst írni illetve mivel iparági-sztenderd, így könnyű hozzá könyvtárakat letölteni és használni.

\subsubsection{Szerver}
A szerver feladata a bejövő kérések kiszolgálása. Ő felel a felhasználók beléptetéséért, nyomonkövetéséért és a játékok kezeléséért. A legtöbb funkció kívülről egy nyílt API-n keresztül elérhető, kivétel a felhasználói regisztráció és adminisztráció,
A szerver rendelkezik egy felhasználói felülettel, ahol a regisztráció és felhasználói adatmódosítás elérhető, illetve innen lehet elérni különböző a játékkal kapcsolatos anyagokat is, mint például az API dokumentáció.

\subsubsection{Humán- és botkliens}
A két fajta kliens nem tér el túlságosan, mindkettőben kell támogatni a beléptetést, nyomonkövetést, játékinformációk szinkronizációját. Amiben viszont eltérnek az, hogy mekkora önállóságuk van. A humánkliensnél a lépéseket az emberi felhasználó határozza meg, míg a botkliensnél egy algoritmus. Adódhat az ötlet, hogy a más felhasználók kihívását is automatizáljuk, de ezt előzetes próbálgatások alapján elég nehéz úgy beállítani, hogy ne árasszák el a botok játékkérésekkel a játékosokat, így ez a funkció is maradhat az emberi felhasználónál. A botkliensekből legyen lehetőség kézzel kihívni másokat, de ne tegye automatikusan. Természetesen emberi játékosok kihívhatják a botokat, azok onnantól kezdve automatikusan kell, hogy válaszoljanak a felkérésekre.
Fontos kitétel a klienseknél, hogy nem szabad leállniuk egy-egy kérésnél. Minden folyamatnak aszinkron kell történnie.
Másik fontos kitétel, hogy nem szabad a klienseknek kivételt dobniuk, hanem le kell tudniuk logolni.


\newpage
\section{Tervezés}
\subsection{Játék-reprezentáció}

\subsubsection{Egy általános táblás játék reprezentációja}

Egy körökreosztott általános táblás játék a következő elemekből áll:

\begin{itemize}
	\item \textbf{Modell} \\
	A játékállás ábrázolása sokrétű lehet. Tárolni kell a játékosok listáját, az aktuális játékost és a játéknak megfelelő állást: táblán lévő bábuk vagy asztalon levő kártyák.
	
	\item \textbf{Szabályok} (avagy játékmechanika) \\
	A szabályok határozzák meg, hogy milyen helyzetben mik a lehetséges lépések. Az ezt kiszolgáló osztály legyen a játékmester, aki hozzányúlhat a reprezentációhoz, így biztosítva, hogy a játék mindig a szabályoknak megfelelően menjen.
\end{itemize}

A fenti felosztásból adódhat a \ref{fig:boardGameAbstractClassDiagram}. ábrán ismertetett osztálydiagram. A \texttt{GameRepresentation} osztály maga a modell. Teljesen "buta", nincs beleépítve logika, csak tárolja a tábla vagy asztal aktuális állapotát és valamilyen módon lehetőséget biztosít a módosítására. Nem szabad semmilyen játék alapelveit beleépíteni, hiszen például egy sakktáblán is lehet többfajta sakkot játszani, amelyek szabályai különbözőek.

A \texttt{Game} osztály a "játékmester", ő az, aki a szabályok szerint módosítja a reprezentációt. Rajta keresztül kell validálni és végrehajtatni a lépéseket, illetve tőle lehet lekérdezni az aktuális meccs állását illetve egyéb fontosabb tulajdonságait.

\begin{figure}[htbp]
	\centering
	\includegraphics[width=\textwidth]{img/boardGameAbstractClassDiagram.png}
	\caption{Egy általános táblás, körökre osztott játék absztrakt reprezentációja}
	\label{fig:boardGameAbstractClassDiagram}
\end{figure}

A \texttt{Generate()} függvény azért van kiszürkítve az ábrán, mert egy játék lehetséges lépései nem fetétlen diszkrét értékek egy véges halmaza. Szigorúan véve csak azt kell megkövetelni a \texttt{Game} osztálytól, hogy el tudja dönteni egy bejövő lépésről, hogy az érvényes-e. A lépések kigenerálása inkább csak a mesterséges intelligencia algoritmusának "jöhetne jól".

\subsubsection{Sakk reprezentáció}

A sakk is két fő részből áll: reprezentáció és játékmechanika. Ezeket a \texttt{ChessBoard} és a \texttt{ChessGame} osztályok valósítják meg. (Lásd: \ref{fig:chessClassDiagram}. ábra.)

\begin{figure}[htbp]
	\centering
	\includegraphics[width=\textwidth]{img/chessClassDiagram.png}
	\caption{Sakkot reprezentáló osztálydiagram}
	\label{fig:chessClassDiagram}
\end{figure}

A \texttt{ChessBoard} osztály önmagában csak reprezentál, minden \textit{property} írható és olvasható. Tartalmazza a játékosok listáját (fehér, fekete), a soronkövetkező játékost, az eddig megtett lépések listáját, illetve a tábla aktuális állapotát az előzőekben már említett jelzőkkel.

A \texttt{ChessGame} osztály felelős a játék kezeléséért, betartja a szabályokat, segít a lehetséges lépések kigenerálásában, validációjában és végrehajtásában. Fontos, hogy a teljes szeparáltság miatt a \texttt{ChessGame} osztálynak kizárólag egy számára átadott \texttt{ChessBoard} osztályból tudnia kell a lehetséges lépéseket, a parti állását, stb.

Felmerülhet, hogy miért nincs egyben ez a két osztály. Ennek több oka van:

\begin{itemize}
	\item \textbf{Egy felelősség alapelve} \textit{(Single responsibility principle)}\cite{SingleResponsibilityHu}~\cite{SingleResponsibilityEn}~\cite{SOLID}~ \\
	Ha egy osztály lenne, az túl bonyolulttá tenné ezt az osztályt: több felelősséget rakna rá és így megsértené a \textit{single responsibility} elvét.
	
	\item \textbf{Könnyebb felhasználhatóság} \\
	A mesterséges intelligencia algoritmusoknak külön érdekes csak a reprezentáció, hiszen ebből tudnak "állást számolni". Így az aktuális állás osztályozásához nem kell egy mindent tudó objektumot minden egyes lépésben létrehozni, elég csak a reprezentációt átadni a megfelelő kiértékelő függvénynek.
	
	\item \textbf{Jövőbeli továbbfejleszthetőség} \\
	Sokféle sakkjáték ismeretes, így csak a \texttt{ChessGame} osztály kicserélésével egy másik játékot tudunk készíteni. (Például francia sakk.)
	
	\item \textbf{Tesztelhetőség} \\
	Ha tiszták és minél egyszerűbbek a különböző részei a játékreprezentációnak, annál könnyebb fókuszált \textit{unit-teszteket} írni ezekre.
\end{itemize}

\subsection{Algoritmusok}
asdf
\subsection{Infrastruktúra}
\subsubsection{Kommunikáció a szerver és a kliensek között}
A kommunikáció \textbf{JSON} üzenetek formájában, HTTP verb-ekkel és HTTP status kódokkal történik, ahogy a \ref{fig:clientServerCommunication} ábrán látható.

\begin{figure}[htbp]
	\centering
	\includegraphics[width=0.8\textwidth]{img/clientServerCommunication.png}
	\caption{Kliens - szerver közötti kommunikáció sémája}
	\label{fig:clientServerCommunication}
\end{figure}

\subsubsection{Publikus API}
A RESTful szolgáltatások mintáját követve minden végpont egy-egy entitásra vonatkozó műveleteket végezhet el:

	% == Szerver - felhasználói fiókok ====================================================================================
	\begin{longtable}[c]{|c|p{14cm}|}
	\hline
	\rowcolor[HTML]{6665CD}
	\multicolumn{2}{|l|}{\cellcolor[HTML]{6665CD}{\color[HTML]{FFFFFF} \textbf{Szerver funkciói}}} \\ \hline
	\endfirsthead
	%
	\multicolumn{2}{c}%
	{{\bfseries Table \thetable\ folytatása az előző oldalról...}} \\
	\hline
	\rowcolor[HTML]{6665CD} 
	\multicolumn{2}{|l|}{\cellcolor[HTML]{6665CD}{\color[HTML]{FFFFFF} \textbf{Szerver funkciói}}} \\ \hline
	\endhead
	
	% -----------------------------------------------------------------------------------------------------------------------
	\rowcolor[HTML]{CBCEFB} 
	\textbf{1}
	&	Bejelentkezés
	\\ \nobreakhline
	
	\textbf{GIVEN} &
	A szerver fut.
	\\ \nobreakhline
	
	\textbf{WHEN} &
	Beérkezik egy bejelentkezési kérés egy felhasználói névvel és jelszóval.
	(ACCOUNT végpont, POST metódus)
    \\
	\nobreakhline
	
	\textbf{THEN} &
	A szerver a felhasználói név és jelszó ellenőrzése után visszajelez a kliensnek.
	Ha sikeres volt a belépés, akkor kap egy "JWT token"-t és 200OK üzenetet.
	Autentikációs hiba esetén 401-es hibát jelez, egyéb probléma esetén 500-as hibát jelez.
	\\
	\hline
	
	% -----------------------------------------------------------------------------------------------------------------------
	\rowcolor[HTML]{CBCEFB} 
	\textbf{2}
	&	Belépési token meghosszabbítása
	\\ \nobreakhline
	
	\textbf{GIVEN} &
	A szerver fut.
	\\ \nobreakhline
	
	\textbf{WHEN} &
	Beérkezik egy kérés egy tokennel azzal a szándékkal, hogy az érvényessége meg legyen hosszabbítva.
    (TOKEN végpont, POST metódus)
	\\
	\nobreakhline
	
	\textbf{THEN} &
	A szerver leellenőrzi a token-t és ha még érvényes, akkor egy meghosszabbított token-t ad vissza és 200OK-t.
	Autentikációs hiba esetén 401-es hibát jelez, egyéb probléma esetén 500-as hibát jelez.
	\\
	\hline
	
	% -----------------------------------------------------------------------------------------------------------------------
	\rowcolor[HTML]{CBCEFB} 
	\textbf{3}
	&	Szerver-státusz lekérdezése ("Health-check")
	\\ \nobreakhline
	
	\textbf{GIVEN} &
	-
	\\ \nobreakhline
	
	\textbf{WHEN} &
	Beérkezik egy kérés a szerverhez, amelyben a kliens érdeklődik a szerver státusza (fut-e?) iránt.
	(HEALTH végpont, GET metódus)
	\\
	\nobreakhline
	
	\textbf{THEN} &
	Ha a szerver fut, akkor visszaküldi a verziószámát és 200OK státuszt.
	Bármilyen hiba esetén 500-as státuszt küld, vagy nem válaszol.
	\\
	\hline
	
	% -----------------------------------------------------------------------------------------------------------------------
	\rowcolor[HTML]{CBCEFB} 
	\textbf{4}
	&	Játékosok lekérdezése
	\\ \nobreakhline
	
	\textbf{GIVEN} &
	A szerver fut, a kliens rendelkezik érvényes token-nel.
	\\ \nobreakhline
	
	\textbf{WHEN} &
	Beérkezik egy kérés a szerverhez, amelyben a kliens lekéri a játékosok listáját.
	(PLAYERS végpont, GET metódus)
	\\
	\nobreakhline
	
	\textbf{THEN} &
	A szerver visszaküldi a játékosok listáját (ha érvényes volt a token) egy 200OK státusz mellett.
	Autentikációs hiba esetén 401-es hibát jelez, egyéb probléma esetén 500-as hibát jelez.
	\\
	\hline
	
	% -----------------------------------------------------------------------------------------------------------------------
	\rowcolor[HTML]{CBCEFB} 
	\textbf{5}
	&	Partik lekérdezése
	\\ \nobreakhline
	
	\textbf{GIVEN} &
	A szerver fut, a kliens rendelkezik érvényes token-nel.
	\\ \nobreakhline
	
	\textbf{WHEN} &
	Beérkezik egy kérés a szerverhez, amelyben a kliens lekéri az aktuális játékos partijainak listáját.
	(CHESSGAMES végpont, GET metódus)
	(CHESSGAMES/DETAILED végpont, GET metódus)
	\\
	\nobreakhline
	
	\textbf{THEN} &
	A szerver visszaküldi a partik listáját (illetve a részletes állásokat is, ha a CHESSGAMES/DETAILED végpontot hívta a kliens.) és 200Ok státuszt.
	Autentikációs hiba esetén 401-es hibát jelez, egyéb probléma esetén 500-as hibát jelez.
	\\
	\hline
	
	% -----------------------------------------------------------------------------------------------------------------------
	\rowcolor[HTML]{CBCEFB} 
	\textbf{6}
	&	Lépés
	\\ \nobreakhline
	
	\textbf{GIVEN} &
	A szerver fut.
	\\ \nobreakhline
	
	\textbf{WHEN} &
	Beérkezik egy kérés a szerverhez, amelyben a kliens közli, hogy melyik partin milyen lépést szeretne kezdeményezni. (CHESSGAMES végpont, PUT metódus)
	\\
	\nobreakhline
	
	\textbf{THEN} &
	A szerver ellenőrzi, majd végrehajtja és lementi a lépést, erről visszaigazolást küld a legfrisebb állással és 200OK státusszal.
	Autentikációs hiba esetén 401-es hibát jelez, egyéb probléma esetén 500-as hibát jelez.
	\\
	\hline
	
	% -----------------------------------------------------------------------------------------------------------------------
	\rowcolor[HTML]{CBCEFB} 
	\textbf{7}
	&	Kihívás
	\\ \nobreakhline
	
	\textbf{GIVEN} &
	A szerver fut.
	\\ \nobreakhline
	
	\textbf{WHEN} &
	Beérkezik egy kérés a szerverhez, amelyben a kliens közli, hogy melyik felhasználót szeretné kihívni. (CHESSGAMES végpont, POST metódus)
	\\
	\nobreakhline
	
	\textbf{THEN} &
	A szerver ellenőrzi a kérést, majd ha rendben találja, kisorsolja hogy melyik játékos lesz a fehér, majd létrehozza a játékot és visszaküldi a meccs alapinformációit a kliensnek egy 200-as státusszal.
	Autentikációs hiba esetén 401-es hibát jelez, egyéb probléma esetén 500-as hibát jelez.
	\\
	\hline
	
	% -----------------------------------------------------------------------------------------------------------------------
	\rowcolor[HTML]{CBCEFB} 
	\textbf{8}
	&	Eredmények
	\\ \nobreakhline
	
	\textbf{GIVEN} &
	A szerver fut.
	\\ \nobreakhline
	
	\textbf{WHEN} &
	Beérkezik egy kérés a szerverhez, amelyben a kliens le akarja tölteni a felhasználók aktuális pontjait. (LADDER végpont, POST metódus)
	\\
	\nobreakhline
	
	\textbf{THEN} &
	A szerver a befejezett játékok alapján kiszámolja és visszaküldi a felhasználók toplistáját 200OK státusszal.
	\\
	\hline
	
	\caption{Szerver alapfunkciói - API}
	\label{userStories:server:api}\\
\end{longtable} 

\subsubsection{Szerver UI}
Minimalista, csak dokumentációt, letöltéseket, felhasználó regisztráció és menedzsment elérhető róla. (\ref{fig:serverUiMainScreen}. ábra):

\begin{figure}[htbp]
	\centering
	\includegraphics[width=1.0\textwidth]{img/serverUiMainScreen.png}
	\caption{Szerver fő felület}
	\label{fig:serverUiMainScreen}
\end{figure}

\subsubsection{Dokumentáció}
A később részletezett open-API dokumentációját a swagger nevű generátorral oldjuk meg, amely felépítését mutatja a \ref{fig:serverUiDocumentation}. ábra.

\begin{figure}[htbp]
	\centering
	\includegraphics[width=1.0\textwidth]{img/serverUiDocumentation.png}
	\caption{Szerver - generált dokumentáció}
	\label{fig:serverUiDocumentation}
\end{figure}
Az API dokumentációt a \textit{swagger}\cite{swaggerHomepage} generálja a kód, az annotációk és '\textit{summary}' tag-ek alapján.

A swagger generál egy az API-t leíró sémafile-t is, amelyet felhasználva a swagger oldalán generáltathatunk egy kliens a legtöbb nyelvre.

\begin{lstlisting}[caption=Health-check példakód 'summary' tag-ekkel., label=lst:healtcheck]
/// <summary>
/// The health controller. Only used to return the version information.
/// (Can only respond when the service is up and running.)
/// </summary>
[Route("api/Health")]
public class HealthController : Controller
{
/// <summary>
/// Health check. Returns the version number of the service.
/// </summary>
/// <returns>The version information of the service.</returns>
[ProducesResponseType(typeof(string), (int)HttpStatusCode.OK)]
[HttpGet]
public async Task<IActionResult> Get()
{
var version = Microsoft.Extensions
.PlatformAbstractions
.PlatformServices
.Default
.Application
.ApplicationVersion;

return Ok(version);
}
}
\end{lstlisting}

A fenti kódban a \texttt{Get()} függvény \textit{summary} szövege lesz az API végpont dokumentációjában, a \texttt{ProducesResponseType} attribute class-szal pedig jelezhetjük, hogy milyen HTTP státuszjelzés mellett milyen modell jön vissza a szervertől. Például: '200 OK' mellett visszajön egy várt komplex objektum, de mondjuk '500 ERROR' mellett visszajön egy komplex hibaobjektum, nem csak maga a hibakód és az esetleges hibaüzenet.


\subsection{A Kliens}

\subsubsection{Alapfunkciók} \mbox{} \\
A klienseknek a következő alapfunkcionalitást kell minimum kiszolgálniuk:

% == Kliens - indulás ===================================================================================================
\begin{longtable}[c]{|c|p{14cm}|}
	\hline
	\rowcolor[HTML]{6665CD}
	\multicolumn{2}{|l|}{\cellcolor[HTML]{6665CD}{\color[HTML]{FFFFFF} \textbf{Kliens indítása}}} \\ \hline
	\endfirsthead
	%
	\multicolumn{2}{c}%
	{{\bfseries Table \thetable\ folytatása az előző oldalról...}} \\
	\hline
	\rowcolor[HTML]{6665CD} 
	\multicolumn{2}{|l|}{\cellcolor[HTML]{6665CD}{\color[HTML]{FFFFFF} \textbf{Kliens indítása}}} \\ \hline
	\endhead
	%
	\rowcolor[HTML]{CBCEFB} 
	
	% -----------------------------------------------------------------------------------------------------------------------
	\textbf{1}
	&	Alkalmazás indítása
	\\ \nobreakhline
	
	\textbf{GIVEN} &
	A kliens telepítve van.
	\\ \nobreakhline
	
	\textbf{WHEN} &
	A felhasználó jelzi a játék indításának szándékát.
	\\
	\nobreakhline
	
	\textbf{THEN} &
	A kilens elindul és:
	\begin{itemize}
		\item Megjelenik a felület a hitelesítési alfelülettel.
	\end{itemize} 
	\\
	\hline
	
	\caption{Kliens alapfunkciói - indítás}
	\label{userStories:client:start}\\
\end{longtable} 


% == Kliens - hitelesítési felület ======================================================================================
\begin{longtable}[c]{|c|p{14cm}|}
	\hline
	\rowcolor[HTML]{6665CD}
	\multicolumn{2}{|l|}{\cellcolor[HTML]{6665CD}{\color[HTML]{FFFFFF} \textbf{Kliens - Hitelesítési felület}}} \\ \hline
	\endfirsthead
	%
	\multicolumn{2}{c}%
	{{\bfseries \thetable\ folytatása az előző oldalról...}} \\
	\hline
	\rowcolor[HTML]{6665CD} 
	\multicolumn{2}{|l|}{\cellcolor[HTML]{6665CD}{\color[HTML]{FFFFFF} \textbf{Kliens - Hitelesítés}}} \\ \hline
	\endhead
	
	% -----------------------------------------------------------------------------------------------------------------------
	\rowcolor[HTML]{CBCEFB} 
	\textbf{1}
	&	Kilépés
	\\ \nobreakhline
	
	\textbf{GIVEN} &
	Hitelesítési felület aktív.
	\\ \nobreakhline
	
	\textbf{WHEN} &
	Kilépési szándék jelzése (majd annak pozitív megerősítése).
	\\
	\nobreakhline
	
	\textbf{THEN} &
	Alkalmazás bezárása.
	\\
	\hline
	
	% -----------------------------------------------------------------------------------------------------------------------
	\rowcolor[HTML]{CBCEFB} 
	\textbf{2}
	&	Hitelesítés
	\\ \nobreakhline
	
	\textbf{GIVEN} &
	Hitelesítési felület aktív.
	\\ \nobreakhline
	
	\textbf{WHEN} &
	\begin{itemize}
		\item Felhasználói név és jelszó megadása.
		\item Belépési szándék jelzése.
	\end{itemize}
	\\
	\nobreakhline
	
	\textbf{THEN} &
	Adatok elküldése hitelesítésre a szerverhez.
	\begin{itemize}
		\item Ha az adatok megfelelőek:
		\begin{itemize}
			\item Felhasználó beléptetése.
			\item Hitelesítési felület elrejtése.
			\item Lobbi megjelenítése, partik állapotának lekérdezése.
		\end{itemize}
		
		\item Ha az adatok nem megfelelőek:
		\begin{itemize}
			\item Felhasználói tájékoztatása problémáról.
		\end{itemize}
	\end{itemize}
	\\
	\hline
	
	\caption{Kliens alapfunkciói - hitelesítési felület}
	\label{userStories:client:authentication}\\
\end{longtable}

% == Kliens - lobbi =====================================================================================================
\begin{longtable}[c]{|c|p{14cm}|}
	\hline
	\rowcolor[HTML]{6665CD}
	\multicolumn{2}{|l|}{\cellcolor[HTML]{6665CD}{\color[HTML]{FFFFFF} \textbf{Kliens - Lobbi}}} \\ \hline
	\endfirsthead
	%
	\multicolumn{2}{c}%
	{{\bfseries \thetable\ folytatása az előző oldalról...}} \\
	\hline
	\rowcolor[HTML]{6665CD} 
	\multicolumn{2}{|l|}{\cellcolor[HTML]{6665CD}{\color[HTML]{FFFFFF} \textbf{Kliens - Lobbi}}} \\ \hline
	\endhead
	
	% -----------------------------------------------------------------------------------------------------------------------
	\rowcolor[HTML]{CBCEFB} 
	\textbf{1}
	&	Kilépés
	\\ \nobreakhline
	
	\textbf{GIVEN} &
	A felület aktív.
	\\ \nobreakhline
	
	\textbf{WHEN} &
	Kilépési szándék (majd annak megerősítése).
	\\
	\nobreakhline
	
	\textbf{THEN} &
	Alkalmazás bezárása.
	\\
	\hline
	
	% -----------------------------------------------------------------------------------------------------------------------
	\rowcolor[HTML]{CBCEFB} 
	\textbf{2}
	&	Új játék kezdeményezése
	\\ \nobreakhline
	
	\textbf{GIVEN} &
	A lobbi-felület aktív.
	\\ \nobreakhline
	
	\textbf{WHEN} &
	Bejelentkezett játékosok közül leendő ellenfél kiválasztva, új játék kezdésének szándéka.
	\\
	\nobreakhline
	
	\textbf{THEN} &
	Új játék kezdeményezésére vonatkozó kérelem elküldése szervernek.
	\\
	\hline
	
	% -----------------------------------------------------------------------------------------------------------------------
	\rowcolor[HTML]{CBCEFB} 
	\textbf{3}
	&	Partik listájának megtekintése
	\\ \nobreakhline
	
	\textbf{GIVEN} &
	A felület aktív.
	\\ \nobreakhline
	
	\textbf{WHEN} &
	Partik megtekintésének szándéka.
	\\
	\nobreakhline
	
	\textbf{THEN} &
	Partik felület mutatása.
	\\
	\hline
	\caption{Kliens alapfunkciói - lobbi}
	\label{userStories:client:lobby}\\
\end{longtable}

% == Kliens - partik listája ============================================================================================
\begin{longtable}[c]{|c|p{14cm}|}
	\hline
	\rowcolor[HTML]{6665CD}
	\multicolumn{2}{|l|}{\cellcolor[HTML]{6665CD}{\color[HTML]{FFFFFF} \textbf{Kliens - Partik listája}}} \\ \hline
	\endfirsthead
	%
	\multicolumn{2}{c}%
	{{\bfseries \thetable\ folytatása az előző oldalról...}} \\
	\hline
	\rowcolor[HTML]{6665CD} 
	\multicolumn{2}{|l|}{\cellcolor[HTML]{6665CD}{\color[HTML]{FFFFFF} \textbf{Kliens - Partik listája}}} \\ \hline
	\endhead
	
	% -----------------------------------------------------------------------------------------------------------------------
	\rowcolor[HTML]{CBCEFB} 
	\textbf{1}
	&	Kilépés
	\\ \nobreakhline
	
	\textbf{GIVEN} &
	A felület aktív.
	\\ \nobreakhline
	
	\textbf{WHEN} &
	Kilépési szándék (majd annak megerősítése).
	\\
	\nobreakhline
	
	\textbf{THEN} &
	Alkalmazás bezárása.
	\\
	\hline
	
	% -----------------------------------------------------------------------------------------------------------------------
	\rowcolor[HTML]{CBCEFB} 
	\textbf{3}
	&	Kiválasztott játék megjelenítése
	\\ \nobreakhline
	
	\textbf{GIVEN} &
	A felület aktív, partik listájában egy játék ki van választva.
	\\ \nobreakhline
	
	\textbf{WHEN} &
	Parti megtekintésének kezdeményezése.
	\\
	\nobreakhline
	
	\textbf{THEN} &
	Játékfelület mutatása.
	\\
	\hline
	\caption{Kliens alapfunkciói - partik listája felület}
	\label{userStories:client:parties}\\
\end{longtable}

% == Kliens - játékfelület ==============================================================================================
\begin{longtable}[c]{|c|p{14cm}|}
	\hline
	\rowcolor[HTML]{6665CD}
	\multicolumn{2}{|l|}{\cellcolor[HTML]{6665CD}{\color[HTML]{FFFFFF} \textbf{Kliens - partik listája}}} \\ \hline
	\endfirsthead
	%
	\multicolumn{2}{c}%
	{{\bfseries \thetable\ folytatása az előző oldalról...}} \\
	\hline
	\rowcolor[HTML]{6665CD} 
	\multicolumn{2}{|l|}{\cellcolor[HTML]{6665CD}{\color[HTML]{FFFFFF} \textbf{Kliens - partik listája}}} \\ \hline
	\endhead
	
	% -----------------------------------------------------------------------------------------------------------------------
	\rowcolor[HTML]{CBCEFB} 
	\textbf{1}
	&	Kilépés
	\\ \nobreakhline
	
	\textbf{GIVEN} &
	A felület aktív.
	\\ \nobreakhline
	
	\textbf{WHEN} &
	Kilépési szándék (majd annak megerősítése).
	\\
	\nobreakhline
	
	\textbf{THEN} &
	Alkalmazás bezárása.
	\\
	\hline
	
	% -----------------------------------------------------------------------------------------------------------------------
	\rowcolor[HTML]{CBCEFB} 
	\textbf{2}
	&	Lépés
	\\ \nobreakhline
	
	\textbf{GIVEN} &
	A felület aktív.
	\\ \nobreakhline
	
	\textbf{WHEN} &
	Lépési szándék vagy feladás/döntetlen felajánlása ellenfélnek a sakk szabályai szerint.
	\\
	\nobreakhline
	
	\textbf{THEN} &
	Kérés elküldése szervernek, majd a játékállapot frissítése.
	\\
	\hline
	
	% -----------------------------------------------------------------------------------------------------------------------
	\caption{Kliens alapfunkciói - Játékfelület}
	\label{userStories:client:gameScreen}\\
\end{longtable}

\newpage
\subsubsection{Működés}
(A kliensek UI terveit lásd: \ref{fig:humanClient} és \ref{fig:botClient} ábra.)
A képeken látszik, hogy a két kliens nagyon hasonlít egymáshoz hiszen funkcionalitásban is elég közel állnak egymáshoz.

A különböző tabok között szabadon válthat a felhasználó. Minden tabváltáskor történik egy frissítés, amely hatására az összes oldalon levő UI elem frissül. Természetesen a frissítés a háttérben kell, hogy történjen, a UI nem "fagyhat le".

A terveken nincs kiemelve, de mindkét kliensben van egy \textbf{Log} és egy \textbf{Read me} tab. Előbbi hibakereséskor jön majd jól, ugyanis a klienseknek nem szabad semmilyen \textit{exception}-t dobni, viszont mindent le kell logolnia. A \textit{Read me} tab tartalmazza a klienshez a hasznos tudnivalókat, figyelmeztetéseket.

\begin{figure*}
	\centering
	\begin{subfigure}[b]{0.475\textwidth}
		\centering
		\includegraphics[width=\textwidth]{img/humanClientLogin.png}
		\caption{Belépő képernyő}
		\label{humanClientLogin}
	\end{subfigure}
	\hfill
	\begin{subfigure}[b]{0.475\textwidth}  
		\centering 
		\includegraphics[width=\textwidth]{img/humanClientMatches.png}
		\caption{Partik}
		\label{fig:humanClientMatches}
	\end{subfigure}
	\vskip\baselineskip
	\begin{subfigure}[b]{0.475\textwidth}   
		\centering 
		\includegraphics[width=\textwidth]{img/humanClientGame.png}
		\caption{Bot vezérlése}
		\label{fig:humanClientGame}
	\end{subfigure}
	\quad
	\begin{subfigure}[b]{0.475\textwidth}   
		\centering 
		\includegraphics[width=\textwidth]{img/humanClientPlayers.png}
		\caption{Játékosok listája}
		\label{fig:humanClientPlayers}
	\end{subfigure}
	\vskip\baselineskip
	\begin{subfigure}[b]{0.475\textwidth}   
	\centering 
	\includegraphics[width=\textwidth]{img/humanClientLadder.png}
	\caption{Toplista}
	\label{fig:humanClientLadder}
	\end{subfigure}

	\caption[ Humánkliens UI terv ]
	{\small Humánkliens UI terv}
	\label{fig:humanClient}
\end{figure*}


\begin{figure*}
	\centering
	\begin{subfigure}[b]{0.475\textwidth}
		\centering
		\includegraphics[width=\textwidth]{img/botClientLogin.png}
		\caption{Belépő képernyő}
		\label{botClientLogin}
	\end{subfigure}
	\hfill
	\begin{subfigure}[b]{0.475\textwidth}  
		\centering 
		\includegraphics[width=\textwidth]{img/botClientMatches.png}
		\caption{Partik}
		\label{fig:botClientMatches}
	\end{subfigure}
	\vskip\baselineskip
	\begin{subfigure}[b]{0.475\textwidth}   
		\centering 
		\includegraphics[width=\textwidth]{img/botClientGame.png}
		\caption{Bot vezérlése}
		\label{fig:botClientGame}
	\end{subfigure}
	\quad
	\begin{subfigure}[b]{0.475\textwidth}   
		\centering 
		\includegraphics[width=\textwidth]{img/botClientPlayers.png}
		\caption{Játékosok listája}
		\label{fig:botClientPlayers}
	\end{subfigure}
	\caption[ Botkliens UI terv ]
	{\small Botkliens UI terv}
	\label{fig:botClient}
\end{figure*}


























































\newpage
\section{Megvalósítás}

\subsection{Játék-reprezentáció}
A sakktáblát reprezentáló \texttt{ChessBoard} osztály az előzőekben részletezett alapelveknek felel meg. (Lásd.: \ref{lst:chessboard_code} kódrészlet.)
\begin{itemize}
	\item \textbf{Reprezentálja a táblát.}
	\item \textbf{Nincs szabály beleépítve.} \\ 
	Habár sakkbábukkal és sakklépésekkel dolgozik. Ezt lehetne tovább általánosítani, hogy tényleg csak egy tábla legyen, de a céljainknak egyelőre ez megfelelő.
\end{itemize}

A legfontosabb függvény a \texttt{Move(from, to)} függvény, amely elvégzi a módosításokat a táblán, ám a \texttt{History}-ba nem írja be, az majd a "játékmester" feladata lesz. Továbbá a \texttt{Move()} függvény visszatérési értéke a "leütött" bábu, vagy \texttt{null} ha üres volt. (Lásd.: \ref{lst:chessboard_code} kódrészlet.)

\begin{lstlisting}[caption=Sakktábla implementáció vázlat, label=lst:chessboard_code]
public class ChessBoard : IChessBoard, ICloneable<ChessBoard>
{
	private ChessPiece[] pieces = new ChessPiece[64];

	public ChessBoard()	{ /*..*/ }

	public ChessPiece this[Position position]
	{
		get { /* ... */ }
		set { /* ... */ }
	}

	public ChessPlayer CurrentPlayer { get; set; }

	public IEnumerable<ChessPlayer> Players { get; set; }

	public List<ChessMove> History { get; set; }

	public ChessBoard Clone() { /* ... */ }

	public ChessPiece Move(Position from, Position to)
	{
		/* ... */
	}
}
\end{lstlisting}

A sakktáblát egy egydimenziós tömb tárolja, amin a tájékozódás kissé nehézkés, ezért a sakkhoz jobban illő \texttt{Position} tipuson keresztül lesz ez megkönnyítve, amely az algebrai lejegyzést használja. (Lásd \ref{lst:chessboardposition_code}. kódrészlet.)

\begin{lstlisting}[caption=Pozíciók a sakktáblán - Position osztály, label=lst:chessboardposition_code]
/// <summary>
/// Represents a position in the chess board.
/// </summary>
public sealed class Position : IEquatable<Position>
{
	public Position(string notation) { /* ... */ }
	
	public Position(char column, int row) { /* ... */ }
	
	public char Column { get; }
	
	public int Row { get; }
	
	// ...
}
\end{lstlisting}

A későbbi fejlesztések segítéséhez az osztály tartalmaz konvertereket (array index és pozíció között oda-vissza) és egyenlőségvizsgálatot is, hogy írhassuk: \texttt{p1 == p2} vagy \texttt{p1.Equals(p2)}.

Ezeken kívül - kissé lazábban kapcsolódva a szigorúan vett feladathoz - implementálva lett a \texttt{Position} osztályhoz néhány kiterjesztés is, amely a sokszor használt pozícióval kapcsolatos műveleteket implementálja. Ilyen például az "északi irányba lépés" vagy a "lólépés", illetve a diagonális, horizontális és vertikális lépések listájának kigenerálása. Ezt valósítja meg a \texttt{PositionExtensions} osztály (Lásd \ref{lst:chessboardpositionextensions_code}. kódrészlet).

\begin{lstlisting}[caption=Pozíciók segédfüggvényes - PositionExtensions osztály, label=lst:chessboardpositionextensions_code, float,floatplacement=H]]
public static class PositionExtensions
{
	public static Position ParsePostal(this string postalNotation) { /* ... */ }
	
	public static Position North(this Position position, int number = 1) { /* ... */ }
	public static Position South(this Position position, int number = 1) { /* ... */ }
	public static Position West(this Position position, int number = 1) { /* ... */ }
	public static Position East(this Position position, int number = 1) { /* ... */ }
	public static Position NorthEast(this Position position, int number = 1) { /* ... */ }
	
	/* ... */
	
	public static Position KnightNorthEast(this Position position)
	{
		var newPosition = position.North(2).East(1);
		return newPosition;
	}
	
	public static Position KnightNorthWest(this Position position) { /* ... */ }
	
	/* ... */
	
	public static IEnumerable<Position> KnightMoves(this Position position)
	{
		var possibleMoves = new []
		{
			position.KnightSouthWest(),
			position.KnightSouthEast(),
			position.KnightWestSouth(),
			position.KnightWestNorth(),
			position.KnightEastSouth(),
			position.KnightEastNorth(),
			position.KnightNorthWest(),
			position.KnightNorthEast()
		}.Where(x => x != null);
		
		return possibleMoves;
	}
	
	public static IEnumerable<Position> Northwards(this Position position, int maxRadius = int.MaxValue) { /* ... */ }
	
	/* ... */
	
	public static IEnumerable<Position> StraightMoves(this Position position, int maxRadius = int.MaxValue) { /* ... */ }
	public static IEnumerable<Position> DiagonalMoves(this Position position, int maxRadius = int.MaxValue) { /* ... */ }
	public static IEnumerable<Position> AllDirectionsMove(this Position position, int maxRadius = int.MaxValue) { /* ... */ }
}

\end{lstlisting}

A kiterjesztési függvények segítségével szép láncolt kifejezéseket lehet szerkeszteni, példa erre a \texttt{KnightNorthEast} függvény, ahol könnyen leolvasható miből is áll egy észak-keleti irányba lépő huszár: "kettőt északra, egyet keletre".

\subsubsection{A sakk implementációja}

A sakk implementációja sokkal bonyolultabb és felvet néhány érdekes problémát. (Implementáció vázát lásd \ref{lst:chessgame_code}, kódrészlet.)

\begin{lstlisting}[caption=Sakk szabályok implementációja, label=lst:chessgame_code]
public class ChessGame : IMechanism<ChessGameRepresentation, ChessMove, GameState>
{
	public IEnumerable<ChessMove> GenerateMoves(ChessGameRepresentation representation)
	{ 
		/* ... */ 
	}
	
	public GameState GetGameState(ChessGameRepresentation representation)
	{ 
		/* ... */ 
	}
	
	public bool ValidateMove(ChessGameRepresentation representation, ChessMove move)
	{
		return this.GenerateMoves(representation).Contains(move);
	}
	
	public ChessGameRepresentation ApplyMove(ChessGameRepresentation representationParam, ChessMove move)
	{ 
		/* ... */ 
	}
	
	/* ... */
}
\end{lstlisting}

Amint látszik, minden függvény egy bemenő paramétere egy reprezentáció. Ebből állapítja meg, hogy mik a lehetséges lépések (\texttt{GenerateMoves}), egy megadott lépés helyes-e az adott helyzetben (\texttt{ValidateMove}) és alkalmazza a megadott lépést ha helyes (\texttt{ApplyMove}).

Ezeket külön-külön megvizsgáljuk:

\paragraph{GenerateMoves()} \mbox{} \\
A \texttt{GenerateMoves} függvény az egész osztály legfontosabb függvénye. Erre építkezik több másik függvény is. Mivel minden állapotban a lehetséges lépések halmaza véges és diszkrét, ezért implementálható és felhasználható más függvényekben is. \textit{(Ha nem lenne implementálható, akkor csak a \texttt{ValidateMove} és az \texttt{ApplyMove} függvényeket lehetne implementálni.)}

A lépések kigenerálásának két lépése van: a naív kigenerálás és az illegális lépések kiszűrése.
\begin{enumerate}
	\item \textbf{Lehetséges lépések naív kigenerálása}
		\begin{itemize}
			\item \textbf{Normál lépések kigenerálása} \\
			A legtöbb bábú ahová léphet, ott üthet is. Így ezen lépések kigenerálása egyszerű, csupán annyi megszorítással például egy futónál, hogy habár bármennyit léphet diagonálisan, bábút nem ugorhat át, így a saját bábú esetében előtte meg kell állnia, vagy ellenfél bábúja esetében azt leütve a helyére kell lépnie és tovább nem mehet.

			\item \textbf{A gyalog lépései} \\
			A gyalog lépéseinek kigenerálása az egyik bonyolult függvény. Eleve ketté kell osztani a lépéseit, ugyanis neki vannak olyan lépései, amelyek nem ütnek. A gyalog csak "srégen előre" tud ütni, viszont lépni (ha van helye) előre is tud. Ezért ezt a két esetet szét kell választani, amely majd jól jön később, amikor a sakkba lépést vizsgáljuk. 

			\item \textbf{Sáncolás} \\
			A sáncolásnak több előfeltétele is van: a benne résztvevő bástya és a király nem mozdulhatott még el a parti alatt, a király nem lehet támadva ("sakkban"), illetve a király által lépdelt mezők sem lehetnek támadva. Ez így elég sok feltétel, ráadásul rendhagyó is. Az előzőekben részletezett lépéseknél könnyen használható a későbbi szűrés, de mivel itt szigorúan véve nem csak egy lépés, hanem egy lépéssorozat történik és minden lépésben meg kell vizsgálni, hogy támadva van-e a sáncolás útvonala, ezért ezt "helyben" kell elvégezni. Ehhez ki kell számolni azokat a mezőket, amelyek támadás alatt vannak. (Ez egy érdekes rekurzív problémához vezet.)
		\end{itemize}
		
	\item \textbf{Szabályokkal ellenkező lépések kiszűrése} \\
		Meg kell vizsgálni, hogy az adott lépés "felfedi-e" a királyt egy támadó bábúnak. Ez esetben a lépés nem lehetséges. Ezt úgy tudjuk megvizsgálni, hogy kiszámoljuk a saját lépésünk utáni támadott mezőket és megnézzük, hogy ezek között szerepel-e a király pozíciója. Ugyanez az eljárás sakk esetén is, hiszen ez esetben pedig csak olyan lépések jöhetnek számításba, amelyek megszüntetik a sakkot. Ha ilyen lépés nem létezik, akkor megtörtént a sakk-matt.
		
		A szűrésnél a másik dolog amire figyelni kell, hogy csak a támadó lépéseket kell figyelembe venni. Ez a gyalog lépéseinél jöhet szóba, hiszen egy gyalog léphet előre, ám ott nem üthet, ezért a király például léphet az ellenfél gyalogja elé. Ezért is kell szétválasztani a gyalog esetében a normál- és ütőlépések kigenerálását.
\end{enumerate}

\paragraph{Egy érdekes rekurziós probléma} \mbox{} \\
A sáncolás kiszámításánál futhatunk bele egy trükkös rekurzióba. A feltételek ellenőrzésének része, hogy megállapítsuk: a megfelelő mezők és bábúk támadva vannak-e. Ehhez meg kell állapítani az éppen az ellenfél által veszélyeztetett mezőket. Ehhez ki kell generálnunk az aktuális helyzettől függő ellenfél lépéseit, amelynek viszont része a sáncolás is. Így egy végtelen rekurzióhoz jutunk. Ezt úgy lehet megszüntetni, hogy a veszélyeztetett mezők kiszámításánál nem vesszük figyelembe az ellenfél sáncolását, hiszen az semmilyen esetben nem lehet hatással a mi sáncolásunkra.

\paragraph{ValidateMove()} \mbox{} \\
Ennél a játéknál szerencsénk van: ha a \texttt{GenerateMoves()} függvény implementálható (azaz a következő lehetséges lépések halmaza véges és diszkrét elemekből áll) akkor nincs más dolgunk, mint megállapítani: a beérkezett lépés benne van-e a kigenerált lehetséges lépések között. Ez látható is a \ref{lst:chessgame_code}. kódrészletben.

\paragraph{GetGameState()} \mbox{} \\
A \texttt{GetGameState} függvény hivatott kiszámolni, hogy mi a játék aktuális állapota? Ha van még lehetséges normál lépés, akkor jelzi, hogy lehet még lépni, ha bármilyen módon vége van (valaki feladta, mattot adott vagy patt-helyzet alakult ki) akkor azt jelzi. Ehhez az utolsó lépést vizsgálva és a \texttt{GenerateMoves} függvényt meghívva számolja ki a kimenetet:

\begin{itemize}
	\item Ha az utolsó lépés egy döntetlen elfogadása $\to$ döntetlen.
	\item Ha az utolsó lépés egy feladás $\to$ ellenfél játékosa nyert.
	\item Ha van még lépés $\to$ A játék folyamatban van.
	\item Ha nincs már lépés, akkor...
	\begin{itemize}
		\item Ha az aktuális játékos sakkban áll $\to$ MATT
		\item Ha az aktuális játékos nem áll sakkban $\to$ PATT (döntetlen)
	\end{itemize}
\end{itemize}

\paragraph{ApplyMove()} \mbox{} \\
Az \texttt{ApplyMove} függvény végrehajtja a megfelelő módosításokat a táblán és a lépést "lejegyzi". Kimenete a módosítás utáni reprezentáció. Ha a lépés nem megengedett \texttt{null}-lal tér vissza.






\newpage
\subsection{Algoritmusok}
Ezért az algoritmus interfésze nem is bonyolult: egyetlen függvénye van, a \texttt{TMove Calculate(TState state)}, amely paraméterként kap egy aktuális állapotot (játék-reprezentációt) és visszatér egy lépéssel. (Lásd: \ref{fig:algorithmAbstractDiagram}. ábra.)

\begin{figure}[htbp]
	\centering
	\includegraphics[width=0.7\textwidth]{img/algorithmAbstractDiagram.png}
	\caption{Absztrakt algoritmus interface és függőségei}
	\label{fig:algorithmAbstractDiagram}
\end{figure}

A konkrét megvalósításhoz kellhet egy kis segítség. Az algoritmusnak sok lehetséges lépésből kell kiválasztania a legmegfelelőbbet. Ehhez két dolog kell:

\begin{itemize}
	\item \textbf{Lépés-generátor} \\
	Az algoritmus nem tud semmit a sakkról és nem is kell neki. Azt, hogy milyen lépések lehetségesek, kívülről kell megadni neki. Ez lehet a sakkhoz készült sima generátor osztály, amely egy adott állapotra kigenerálja az összes lehetséges lépést, vagy pedig egy ennek specializált változata, amely egy megfelelő heurisztika alapján csak azokat a lépéseket generálja ki, amelyeket érdemes megvizsgálni, ezzel is csökkentve az algoritmus futási idejét és erőforrásigényét. \footnote{Olyan is lehetséges, hogy egy játéknak "folytonos" sokaságú lépése, vagy diszkrét, de végtelen számosságú lehetséges lépése létezhet, tehát nem kigenerálható az összes. Ez esetben jöhet jól egy olyan generátor-osztály, amely "diszkrét és véges mennyiségű" lehetséges lépést generál.}
	
	\item \textbf{Kiértékelő} \\
	Kell egy kiértékelő-osztály is, amely eldönti az újonnan előállt állapotról annak értékét az aktuális játékos szemszögéből. Erre jelen esetben az \texttt{integer} megfelelő választás lesz, maximum és minimum értékét (\texttt{int.MaxValue} és \texttt{int.MinValue}) extremális elemként használva. A minimum érték jelentse a $-\infty$-t, a maximum érték pedig jelentse a $+\infty$-t.\footnote{Megjegyzendő, hogy a visszaadott érték nem feltétlen kell, hogy egy sima természetes vagy valós szám legyen, de fontos, hogy az \texttt{TResult Evaulate(TState state)} függvénynek a \texttt{TResult} típusérték-halmazának legalább részben-rendezett halmaznak kell lennie.}
\end{itemize}

Ezek alapján már implementálhatóak az absztrakt algoritmusok. A dolgozatban öt algoritmus van implementálva:
\begin{itemize}
	\item Random algoritmus
	\item Minimax algoritmus
	\item Alfa-béta algoritmus
	\item Átlagoló-minimax algoritmus
	\item Mohó algoritmus
\end{itemize}

Végül ezeket fogja egy-egy bot alkalmazni és ezeket felhasználva fognak egymás ellen sakkozni. \textit{Tegyék meg tétjeiket, Uraim!}

\subsubsection{Előfeltételek}
A \ref{fig:algorithmAbstractDiagram}. ábrán látott interfész elég egyszerű, de a megvalósítás szempontjából több kell. Például mindenképp kell egy generátor, amely kigenerálja a lehetséges lépéseket, és kell egy \textit{alkalmazó} osztály is, amely a megadott lépést alkalmazva az aktuális játékállásra kiad egy új, a szabályoknak és a lépésnek megfelelő új állapotot. Mivel az algoritmusokat a lehető legáltalánosabban akarjuk megírni, ezért ezek interface-ét is definiálni kell.

\paragraph{A generátor interface} egyetlen függvénnyel rendelkezik, egy megadott állapotra alkalmazza visszaadja a lehetséges lépések (egy) halmazát. Az implementációkor alkalmazható egy kis trükk, amely jól fog jönni az alfa-béta algoritmus alkalmazásakor: olyan sorrendbe adjuk vissza a lépéseket, hogy előre vesszük az ütéseket, aztán a tisztmozgásokat, végül az előrelépéseket és a végére hagyva a visszalépéseket. Ezáltal az alfa-béta algoritmus várhatóan jóval több vágást tud elvégezni, mintha össze-vissza, vagy pont fordított sorrendben vizsgálná a lépések hatásait. (\ref{lst:algorithm_generator_code}. kódrészlet.)

\begin{lstlisting}[caption=A generátor interface, label=lst:algorithm_generator_code]
public interface IGenerator<TState, TMove>
{
	IEnumerable<TMove> Generate(TState state);
}
\end{lstlisting}


\paragraph{Az alkalmazó interface} egyetlen függvénnyel rendelkezik, egy megadott állapotra alkalmazza a megadott lépést és visszaadja az új állapotot. (\ref{lst:algorithm_applier_code}. kódrészlet.)

\begin{lstlisting}[caption=Az alkalmazó interface, label=lst:algorithm_applier_code]
public interface IApplier<TState, TMove>
{
	TState Apply(TState state, TMove move);
}
\end{lstlisting}

\paragraph{A kiértékelő interface} egyetlen függvénnyel rendelkezik, a megadott állapotra ad egy pontértéket az aktuális játékos szemszögéből. Extremális elemek az \texttt{int.MaxValue} és az \texttt{int.MinValue}. (\ref{lst:algorithm_evaluator_code}. kódrészlet.)

\begin{lstlisting}[caption=A kiértékelő interface, label=lst:algorithm_evaluator_code]
public interface IEvaluator<TState>
{
	int Evaluate(TState state);
}
\end{lstlisting}



\subsection{Az algoritmusok}

\subsubsection{A Minimax algoritmus}
Ennek megfelelően implementálható a Minimax algoritmus, mely absztrakd UML diagramja \ref{fig:minimaxAbstractDiagram}. ábrán látható.

\begin{figure}[htbp]
	\centering
	\includegraphics[width=0.7\textwidth]{img/minimaxAbstractDiagram.png}
	\caption{MinimaxAlgorithm osztály}
	\label{fig:minimaxAbstractDiagram}
\end{figure}

A minimax algoritmus implementációját a \ref{lst:minimax_code}. kódrészlet mutatja. Ez egyben egy példa is az előzőekben felvázolt \textit{kiértékelő}, \textit{alkalmazó}, és \textit{generátor} függőségek használatára is.

\begin{lstlisting}[caption=Minimax (egszerűsített) kódja, label=lst:minimax_code, float]
public class MinimaxAlgorithm<TState, TMove> : IAlgorithm<TState, TMove>
	where TMove : class
{
	private int _maxDepth;
	
	protected readonly IEvaluator<TState> _evaluator;
	protected readonly IGenerator<TState, TMove> _moveGenerator;
	protected readonly IApplier<TState, TMove> _moveApplier;
	
	public MinimaxAlgorithm(IEvaluator<TState> evaluator, IGenerator<TState, TMove> moveGenerator, IApplier<TState, TMove> applier)
	{
		_evaluator = evaluator;
		_moveGenerator = moveGenerator;
		_moveApplier = applier;
		_maxDepth = 3;
	}
	
	public int MaxDepth { get; set; }
	
	public TMove Calculate(TState state)
	{
		var moves = _moveGenerator.Generate(state);
	
		if(!moves.Any())
		{
			return null;
		}
		
		var movesAndValues = moves.Select(move => new
		{
			Move = move,
			Value = Calculate(_moveApplier.Apply(state, move), 1, false)
		});
		
		return movesAndValues.OrderByDescending(x => x.Value).First().Move;
	}
	
	private int Calculate(TState state, int depth, bool maximize)
	{
		if (depth == MaxDepth)
		{
			return _evaluator.Evaluate(state);
		}
		
		var nextMoves = _moveGenerator.Generate(state).ToList();
		var isLeaf = !nextMoves.Any();
		
		if(isLeaf)
		{
			return _evaluator.Evaluate(state);
		}
		
		var childrenValues = nextMoves.Select(x => _moveApplier.Apply(state, x))
		.Select(x => Calculate(x, depth + 1, !maximize))
		.ToList();
		
		return maximize
		       ? childrenValues.Union(new[] { int.MinValue }).Max()
               : childrenValues.Union(new[] { int.MaxValue }).Min();
	}
}
\end{lstlisting}

\subsubsection{Alfa-béta algoritmus}
Az alfa-béta algoritmus felépítése nagyon hasonló a minimax kódjához, a különbséges a \ref{lst:alphabeta_code}. kódrészlet tartalmazza, Absztrakt UML diagramja \ref{fig:alphabetaAbstractDiagram}. ábrán látható.

\begin{figure}[htbp]
	\centering
	\includegraphics[width=0.7\textwidth]{img/alphabetaAbstractDiagram.png}
	\caption{MinimaxAlgorithm osztály}
	\label{fig:alphaBetaAbstractDiagram}
\end{figure}

A minimax algoritmus implementációját a \ref{lst:alphabeta_code}. kódrészlet mutatja. Ez egyben egy példa is az előzőekben felvázolt \textit{kiértékelő}, \textit{alkalmazó}, és \textit{generátor} függőségek használatára is.

\begin{lstlisting}[caption=Alfa-béta algoritmus, label=lst:alphabeta_code, float]
public TMove Calculate(TState state)
{
	var moves = _moveGenerator.Generate(state);
	
	if (!moves.Any())
	{
		return null;
	}
	
	var movesAndValues = moves.Select(move => new
	{
		Move = move,
		Value = Calculate(_moveApplier.Apply(state, move), 1, int.MaxValue, int.MinValue, false)
	});
	
	return movesAndValues.OrderByDescending(x => x.Value).First().Move;
}

private int Calculate(TState state, int depth, int alpha, int beta, bool maximize)
{
	if (depth == MaxDepth)
	{
		return _evaluator.Evaluate(state);
	}
	
	var nextMoves = _moveGenerator.Generate(state).ToList();
	var isLeaf = !nextMoves.Any();
	
	if (isLeaf)
	{
		return _evaluator.Evaluate(state);
	}
	
	if (maximize)
	{
		var maximizerValue = int.MinValue;
		
		foreach (var mv in nextMoves)
		{
			maximizerValue = (int)Math.Max(maximizerValue, Calculate(_moveApplier.Apply(state, mv), depth + 1, alpha, beta, false));
			alpha = (int)Math.Max(alpha, maximizerValue);
			
			if(alpha >= beta)
			{
				break;
			}
		}
		
		return maximizerValue;
	}
	else
	{
		var minimizerValue = int.MaxValue;
		
		foreach (var mv in nextMoves)
		{
			minimizerValue = (int)Math.Min(minimizerValue, Calculate(_moveApplier.Apply(state, mv), depth + 1, alpha, beta, true));
			beta = (int)Math.Min(beta, minimizerValue);
			
			if (alpha >= beta)
			{
				break;
			}
		}
		
		return minimizerValue;
	}
}
\end{lstlisting}

\subsubsection{Átlagoló Minimax algoritmus}
\lipsum[1]
\subsubsection{Mohó algoritmus}
\lipsum[1]

\subsection{Tesztelés}
Unit-tesztekkel... \textbf{TODO: Esetek leírása.}
\subsubsection{Minimax algoritmus}
\lipsum[1]
\subsubsection{Alfa-béta algoritmus}
\lipsum[1]
\subsubsection{Átlagoló Minimax algoritmus}
\lipsum[1]
\subsubsection{Mohó algoritmus}
\lipsum[1]




\newpage
\section{Megvalósítás}
adfasdfasdf




\newpage
\section{Tesztelés}
\subsection{Sakk reprezentáció tesztelése}

A tesztelés unit-teszteken keresztül történik, amelyben előre megadott szituációkat mutatva a kódnak megvizsgáljuk, hogy a lehetséges lépéseket kapjuk-e meg vagy sem, illetve manuálisan végignézve állásokat megállapítjuk, hogy jók-e az állások. Ehhez készült el egy visualizer...











\subsection{Megvalósítás}
\subsubsection{Szerver}
\lipsum[1]

\subsubsection{Játékkliens}
\lipsum[2]

\subsubsection{Botok}
\lipsum[3]















\subsection{Tesztelés}

\subsubsection{Szerver}
\lipsum[1]

\subsubsection{Játékkliens}
\lipsum[2]

\subsubsection{Botok}
\lipsum[3]











































% ============================================================================================================
% === FELHASZNÁLÓI DOKUMENTÁCIÓ ==============================================================================
% ============================================================================================================
\newpage
\part{Felhasználói Dokumentáció}
\section{Szerver}
\subsection{Telepítés}
\lipsum[6-7]
\subsection{Használat}
\lipsum[6-7]
\newpage
\section{Kliensek}
\subsection{Játékkliens}
\lipsum[1-2]
\subsection{Bot kliensek}
\lipsum[1-2]











































% ============================================================================================================
% === FÜGGELÉK ===============================================================================================
% ============================================================================================================
\newpage
\part{Függelék}
\section{A játékról}
\subsection{Játékok osztályozása}
A \textbf{„kétszemélyes, teljes információjú, diszkrét, véges és determinisztikus, zéró-összegű, játékok”} definíciója egy kis magyarázatot érdemel. A játékokat a kövektező szempontok alapján lehet osztályozni:

\begin{itemize}
	\item \textbf{Játékosok száma} \\
	Ez lehet egy, kettő, vagy n.
	
	\item \textbf{Elérhető információ mennyisége} \\
	A játékosok számára mennyi információ érhető el? Minden információ birtokában vannak-e (pédlául sakk), vagy nem (például egy kártyajáték, ahol nem látják egymás lapjait.)
	
	\item \textbf{Körökre-osztott-e vagy sem?} \\
	Lépések diszkrét sorozatából áll-e a játék vagy folyamatos.
	
	\item \textbf{Lehetséges lépések száma} \\
	Diszkrét esetben a különböző állapotokban lehetséges lépések száma véges vagy végtelen? A játék véges sok lépésben végetér?
	
	\item \textbf{Véletlen-faktor} \\
	A véletlennek van-e szerepe a játékban? Ha nincs, akkor a játékot \textit{determinisztikusnak} hívjuk.
	
	\item \textbf{Játékosok nyereségeinek összege} \\
	Ha a játékosok nyereségeinek összege 0 (amennyit nyer az egyik, annyit veszít a másik), akkor \textit{zérusösszegű} a játék.
\end{itemize}

Ez alapján a sakk egy:
\begin{itemize}
	\item \textbf{Kétszemélyes}
	
	\item \textbf{Tejes információjú} \\
	Ránézve a sakktáblára és a játéklépések jegyzékére minden játékos tudja a pontos állást.
	
	\item \textbf{Diszkrét} \\
	Mert diszkrét lépések sorozata egy játék.
	
	\item \textbf{Véges} \\
	Mivel véges sok lépésben végetér a játék és az állapotokból lehetséges lépések száma is véges.
	
	\item \textbf{Determinisztikus} \\
	Mivel a szerencsének nincs szerepe a játékban.
	
	\item \textbf{Zéró-összegű} \\
	A szerzett pontok száma mindig egy: győztes játékos 1 pontot kap, a vesztes 0-t, döntetlen esetén 0.5-0.5 pontot kapnak a felek.
\end{itemize}
játék.

\subsection{A sakkról}

\subsubsection{Története}
A játék neve a perzsa „shāh” szóból ered, amely uralkodót jelent.\footnote{A "sakk-matt" kifejezés pedig a perzsa „Shāh Māt" kifejezésből származik, amelynek jelentése: "a királyt lerohanták” vagy "védtelen”, "legyőzött”.\cite{ChessMateHu}\cite{ChessMateEn}} Története a legendák világába nyúlik vissza. Egy ismert mese szerint egy brahmin találta ki a sakkot. Jutalmul a rádzsától első hallásra jelentéktelennek tűnő fizetséget kért, mindössze annyi búzaszemet, amennyi a sakktábla kockáira a következő szabály szerint képletesen rátehető: az első kockára egy, a másodikra kettő, a harmadikra négy, vagyis az előzőnek mindig duplája. Hamar kiderült, hogy ennyi búza nem terem a Földön, sőt az emberiség egész történelme alatt nem termelt ennyit.

Az első ismert változata valószínűleg Indiában alakult ki. A maihoz képest egyszerűbb volt, de ugyanakkora táblán és ugyanazokkal a bábukkal játszották, a lépések viszont különböztek. 

Indiából először Perzsiába jutott el. Amikor az arabok elfoglalták Perzsiát, a muszlim világ átvette és ennek következményeként el is terjesztette a játékot Dél-Európában. A sakk mai formáját körülbelül a XV.-ik században érte el.

Keleti terjedése már kissé bizonytalan: először Kínába majd Japánba jutott el és közben sokkal nagyobb változásokon ment keresztül.
\textit{Egy kevésbé elfogadott elmélet szerint eredetileg Kínából származik és terjedt el.}\cite{HistoryOfChessHu}\cite{HistoryOfChessEn}

\subsubsection{A sakk érdekesebb szabályai}
A sakk szabályait nem részleteznénk, ismertnek tételezzük fel, illetve az interneten könnyen hozzáférhető, mint például a \url{http://www.sakk.hu/help/sakk_szabalyok.html} ~\cite{chessrulessakkhu} oldalon. Néhány fontos dolog azért megjegyzendő, amely kissé megbonyolítja a sakk szabályait.

\textit{Egy volt munkahelyemen dekoráció gyanánt ki volt rakva egy sakktábla bábukkal. Ezt az emberek elkezdték használni: kinyomtattak egy papírt, egyik oldalára azt, hogy "fehér jön" a másik oldalára pedig azt, hogy "fekete jön". Ha valakinek volt kedve és ideje, odamehetett, elgondolkodhatott a lépésen, majd miután lépett, megfordította a papírt és várták, hogy valaki lépjen.}

A kérdés az: a meccs "történetének" ismerete nélkül vajon csak a tábla ismeretével kiszámítható-e az összes lehetséges lépés? Ha valaki odalép ehhez a táblához, meg tudja-e mondani az összes lehetséges lépést? A válasz: \textbf{nem}. Vannak különleges lépések, amelyekhez kell ismerni a parti addigi alakulását is. (Sáncolás, en passant)

\subsection{Sakkozó gépek}
\subsubsection{Egy "gondolkodó gép": a Török}
\begin{wrapfigure}{l}{5cm}
	\caption{Kempelen Farkas - A Török}
	\label{fig:the_turk}
	\includegraphics[width=5.0cm]{img/the_turk}
\end{wrapfigure}
A Török Kempelen Farkas által 1769-ben alkotott legendás sakkozógép volt, melyet azért épített, hogy elkápráztassa vele Mária Teréziát. A gép sakkpartikat játszott és nyert. Végül végigtúrázta Európát és Észak-Amerikát míg 1854-ben Philadelphiában egy tűzben meg nem semmisült. 

A gép titka nem egy zseniális korát meghaladó "mechanikus mesterséges intelligencia" volt, hanem egy benne elrejtőző emberi kezelő. Ez a gyanú többször is felvetődött, de Kempelen a játszmák előtt felnyitva a gépet mutatta be, hogy nincs senki a gépben. Valójában az eléggé apró termetű kezelő el tudott bújni, amíg elöl illetve hátul is kinyitották a szerkezetet, hogy belenézhessenek. A gépet végül 1857-ben leplezte le nyíltan a The Chess Monthly című amerikai sakklap.\cite{MechanicalTurkHu}\cite{MechanicalTurkEn}\cite{CsodakKonyveHu}

\subsubsection{Kaissa}
Az 1950-es évektől kezdődően egyre több, egyre erősebb sakkprogramot írtak. 1947-ben készült el a világ első sakk-komputer programja, amelyet Alan Turing írt. 1974-ben volt az első sakkprogram-világbajnokság, ahol a győztes a szovjet Kaissza nevű program volt, amely 1974 és 1977 között uralta a nemzetközi számítógépes sakkot.\cite{chessProgramsHu}

1990-ben elkészíteték PC-s verzióját, amely a londoni számítógépes olimpián negyedik helyezett lett.\cite{KaissaEn}

\subsubsection{Deep Blue}
\begin{wrapfigure}{r}{4cm}
	\caption{Deep Blue}
	\label{fig:deepblue}
	\includegraphics[width=4.0cm]{img/deepblue.jpg}
\end{wrapfigure}
A Deep Blue az IBM által körülbelül 20 millió dolláros költséggel kifejlesztett számítógépe, amely sakkjátékban 1997-ben egy szabályszerű hatjátszmás páros mérkőzésen New Yorkban legyőzte Garri Kaszparovot, az emberi sakkozás akkori világbajnokát.

Első meccs-győzelmét 1996 február 10.-én érte el a világbajnok ellen, de Kasparov három partit nyert és kettőt hozott ki döntetlenre, így 4-2-re győzött a számítógép ellen.

Ezután Deep Blue-t továbbfejlesztették és ekkor már 3,5–2,5-re verte Kasparov-ot 1997 májusában, és ezzel az első számítógépes rendszer lett, amely meg tudta verni az aktuális sakk-világbajnokot a sakkbajnokságokra jellemző időmegszorítás mellett. Kasparov csalást gyanított, és követelt egy visszavágót, ám ebbe az IBM nem ment bele. \cite{DeepBlueHu}\cite{DeepBlueEn}

\section{Az algoritmusokról}

\subsection{A Véletlenszerű algoritmus}
Ez a legegyszerűbb algoritmus, csak azért került be, hogy minél hamarabb lássunk egy egyszerű de működő példát és a koncepciókat a fejlesztés legelején ki lehessen próbálni.
A kigenerált lépések közül választ egyet véletlenszerűen.

\subsection{A mohó algoritmus}
A mohó algoritmusban habár már van logika, az nem feltétlen célravezető. A lehetséges lépések közül azt választja, amelyik a legnagyobb veszteséget okozza a következő körben az ellenfél játékosának. A mohó algoritmus nagy hibája, hogy meg fog találni egy lokális maximumot, de nem feltétlen találja meg a globális maximumot. Ezt egyébként onnan is lehet látni, hogy meglepően agresszíven játszik. Ha lehetséges, üt. Ha lehetséges, sakkot ad, és nem érdekli, hogy utána esetleg veszít egy tisztet.
(Példát lásd \ref{fig:greedyAlgorithmExampleDangerous}. ábra.)
\begin{figure}[htbp]
	\centering
	\includegraphics[width=\textwidth]{img/greedyAlgorithmExampleDangerous.png}
	\caption{Mohó algoritmus működése és ahogy tévútra vezet a lokális maximum.}
	\label{fig:greedyAlgorithmExampleDangerous}
\end{figure}

\subsection{A minimax-algoritmus}
A minimax algoritmus lényege, hogy a legalsó szinten kiértékeli az állásokat, és ezeknek a maximumát illetve minimumát viszi tovább attól függően, hogy melyik szinten van. Első szint a MAX szint, ahol a következő szinten levő csomópontok közül abba az irányba indulunk el, amelyik a legkisebb, ezzel próbálva minimalizálni az ellenfél nyereségét. Következő szint a MIN szint lesz, ahonnan a legnagyobb értékű csomópont felé indulunk el, hogy maximalizáljuk a nyereséget. (Példát lásd \ref{fig:minimaxVsAverageExample}. ábra.)\cite{bevMiHu}
\paragraph{Hatékonyság.} Tegyük fel, hogy minden csomópontból $x$ a lehetséges lépések száma és $d$ a maximum mélység amit vizsgálunk. Ekkor az algoritmus műveletigénye: $ \mathcal{O}(x^d)$.

\subsection{Az átlagoló eljárás}
A minimax algoritmus egy általánosítása. (Avagy a minimax algoritmus az átlagoló eljárás egy speciális esete.) A probléma a statikus kiértékelő-függvényekkel az, hogy lehetetlen olyat megadni, amely megbízhatóan értékeli ki az állásokat. Lehet, hogy egy nagyon jónak ígérkező állásról kiderül, hogy csak egy "csapda" volt és onnan nehezebb vagy lehetetlen megnyerni a meccset. Erre a problémára adhat egy jobb megoldást az átlagoló eljárás. Az ötlet mögötte az, hogy míg az eredeti Minimax algoritmus mindig az aktuális csúcsból elérhető csúcsok minimumát vagy maximumát veszi, addig az átlagoló eljárás a kiterjesztett csúcsok értékeinek MAX szinten az m legnagyobb átlagát, MIN szintjén az n legkisebb átlagát veszi. (Példát lásd \ref{fig:minimaxVsAverageExample}. ábra.)\cite{bevMiHu}

\begin{figure}[htbp]
	\centering
	\includegraphics[width=\textwidth]{img/minimaxVsAverageExample.png}
	\caption{Minimax és Átlagoló eljárás összehasonlítása\cite{bevMiHu}}
	\label{fig:minimaxVsAverageExample}
\end{figure}
\subsubsection{Hatékonyság.} Ugyanaz, mint a minimax algoritmus esetében. Tegyük fel, hogy minden csomópontból $x$ a lehetséges lépések száma és $d$ a maximum mélység amit vizsgálunk. Ekkor az algoritmus műveletigénye: $ \mathcal{O}(x^d)$.

\subsection{Az alfa-béta algoritmus}
Az alfa-béta algoritmus a minimax egy továbbgondolása. Megpróbálja levágni azokat az ágakat, amelyeket nem érdemes már vizsgálni. Ez jól jön a számítási-igény csökkentésénél.

\textbf{TODO: Algoritmus kicsit mélyebb elemzése!}

\subsubsection{Hatékonyság.} Tegyük fel, hogy minden csomópontból $x$ a lehetséges lépések száma és $d$ a maximum mélység amit vizsgálunk.Ekkor a legrosszabb esetben, amikor nem tudunk vágni és ezért minden terminális csúcsot ki kell értékelni, az algoritmus műveletigénye megegyezik a minimax algoritmuséval: $ \mathcal{O}(x^d)$.
Azonban legjobb esetben, ha minden egyes esetben a számítás szemszögéből legjobb csúccsal kezdjük a kiértékelést, ez a műveletigény lecsökken: $\mathcal{O}(\sqrt{x^d})$.
A tapasztalat azt mutatja, hogy az alfa-béta algoritmus legtöbbször ugyanazt az eredményt adja rögzített mélység esetén, mint a minimax algoritmus. Viszont sokkal hatékonyabb, így ha a csúcsok a "megfelelő sorrendben érkeznek kiértékelésre", akkor a keresőfa mélysége akár meg is duplázható. \\ (Összehasonlító ábrát lásd: \ref{fig:alphabeta_examples}. ábra.)

\textbf{TODO: Jobb példát találni erre!}

\begin{figure}[htbp]
	\centering
	\includegraphics[width=\textwidth]{img/alphabeta_examples.png}
	\caption{Alfa-béta algoritmus számítási-igény változása a bejövő adatok sorrendjének függvényében.}
	\label{fig:alphabeta_examples}
\end{figure}

\subsection{Egy érdekes végtelen ciklus}
Vigyázni kell, mert az azonos kezdeti feltételek kombinálva azonos algoritmussal, max-mélységgel és kiértékelő függvénnyel egy végtelen játszmába vezethet. Előfordulhat, hogy a botok elkezdenek oda-vissza lépni és onnantól csak ezt a négy lépést ismételgetni. Ez a probléma a determenisztikus algoritmusoknál jöhet elő, mint például egy minimax-nál, ahol ugyanarra a bemenetre ugyanazzal a kiértékelő függvénnyel és mélységgel ugyanaz az eredmény fog kijönni a végén. Probléma lehet még például ha az egyik oldalon egy minimax, a másikon egy alfa-béta algoritmus fut, hiszen az esetek nagy többségében ezek az algoritmusok ugyanazt az eredményt adják, az alfa-béta csak a minimax egy gyorsítása.

Tehát adott 3 paraméter: algoritmus, mélység, kiértékelő függvény. Ekkor hogy elkerüljük, a végtelen-csapdát a következőket tehetjük:
\begin{itemize}
	\item \textbf{Különnöző kiértékelő függvény} \\ 
	Azonos algoritmus és mélység-beállítás esetén a két botnak különböző kiértékelő függvénye legyen
	
	\item \textbf{Különböző algoritmusok} \\
	Azonos mélység-beállítás és kiértékelő függvény esetén a két botnak ne ekvivalensen determinisztikus algoritmusa legyen. (Például ne legyen minimax és alfa-béta párosítás, de például megy minimax-minimax átlagoló már működhet.)
	
	\item \textbf{Maximális mélység-beállítás legyen különböző} \\
	Azonos algoritmus és kiértékelő függvény esetén a maximális mélység-beállítás legyen különböző
	
	\item \textbf{Nem-determinisztikussá tétel} \\
	Ha mindhárom azonos, akkor pedig lehet egy kis véletlenszerűséget becsempészni akár az algoritmusba, akár a kiértékelő-függvénybe.
\end{itemize}











































% =============================================================================================================
% === IRODALOM- ÁBRAJEGYZÉK ===================================================================================
% =============================================================================================================
\newpage
\bibliographystyle{unsrt}
\part{\bibname}
\bibliography{szakdolgozat}
%\addcontentsline{toc}{part}{\bibname}
%\printbibliography[heading=none]
%\newpage
\listoffigures
\listoftables
%\lstlistoflistings


\end{document}